"""
MCP Forensics - Server Log Transformer
Custom MCP server JSONL log parser

Parses JSONL format log files generated by Custom Remote MCP servers
(main.py, mcp_stdio_proxy.py).

Log file structure:
- requests.jsonl: Client requests (JSON-RPC)
- responses.jsonl: Server responses (JSON-RPC)
- file_access.jsonl: File access records
- errors.log: Error log

Each JSONL line format:
{
    "timestamp": "2024-12-14T10:30:00.123456",
    "type": "request|response|file_access",
    "data": { ... }
}
"""

import json
from pathlib import Path
from typing import Union, Optional, Dict, Any, List, Generator
from datetime import datetime

from .base import BaseTransformer
from ..models import (
    MCPEntities,
    MCPServer,
    MCPTool,
    MCPResource,
    Timeline,
    MCPEvent,
    ToolCallEvent,
    ToolResultEvent,
    FileAccessEvent,
    EventType,
    EventSeverity,
    ServerType,
    TransportType,
    ArtifactSource
)


class ServerLogTransformer(BaseTransformer):
    """
    Custom MCP Server JSONL Log Transformer

    Parses Custom server log files to:
    1. Extract complete JSON-RPC requests/responses
    2. Extract file access events
    3. Identify security events
    4. Build detailed timeline
    """
    
    def __init__(self):
        super().__init__(name="server_log")
        self.source = ArtifactSource.SERVER_LOG
    
    def can_process(self, artifact_path: Union[str, Path]) -> bool:
        """Check if this is a JSONL log file/directory"""
        path = Path(artifact_path)
        
        if path.is_file():
            if path.suffix == ".jsonl":
                return True
            if path.suffix == ".json":
                return self._is_log_json(path)
        
        if path.is_dir():
            jsonl_files = list(path.glob("*.jsonl"))
            if jsonl_files:
                return True
            if (path / "logs").exists():
                return True
        
        return False
    
    def _is_log_json(self, path: Path) -> bool:
        """Check if JSON file is in log format"""
        try:
            with open(path, 'r', encoding='utf-8') as f:
                first_line = f.readline()
                data = json.loads(first_line)
                return "timestamp" in data or "jsonrpc" in data
        except:
            return False
    
    def extract_entities(self, artifact_path: Union[str, Path]) -> MCPEntities:
        """Extract MCP entities from server logs"""
        path = Path(artifact_path)
        entities = MCPEntities()
        entities.analysis_timestamp = datetime.now()
        entities.artifact_sources = [str(path)]
        
        discovered_tools: Dict[str, MCPTool] = {}
        discovered_resources: Dict[str, MCPResource] = {}
        
        server_info = {
            "name": "custom-remote",
            "first_seen": None,
            "last_seen": None,
            "total_requests": 0,
            "total_tool_calls": 0,
            "total_errors": 0,
            "client_ips": set(),
            "session_ids": set()
        }
        
        log_files = self._get_log_files(path)
        
        for log_file in log_files:
            self.logger.info(f"Processing server log: {log_file}")
            
            for entry in self._read_jsonl(log_file):
                timestamp = self._parse_entry_timestamp(entry)
                
                if timestamp:
                    if not server_info["first_seen"] or timestamp < server_info["first_seen"]:
                        server_info["first_seen"] = timestamp
                    if not server_info["last_seen"] or timestamp > server_info["last_seen"]:
                        server_info["last_seen"] = timestamp
                
                client_ip = entry.get("client_ip") or entry.get("data", {}).get("client_ip")
                if client_ip:
                    server_info["client_ips"].add(client_ip)
                
                session_id = entry.get("session_id") or entry.get("data", {}).get("session_id")
                if session_id:
                    server_info["session_ids"].add(session_id)
                
                data = entry.get("data", entry)
                
                if "method" in data:
                    server_info["total_requests"] += 1
                    method = data.get("method", "")
                    
                    if method == "tools/call":
                        server_info["total_tool_calls"] += 1
                        params = data.get("params", {})
                        tool_name = params.get("name", "unknown")
                        
                        if tool_name not in discovered_tools:
                            discovered_tools[tool_name] = MCPTool(
                                name=tool_name,
                                server_name="custom-remote",
                                first_seen=timestamp,
                                call_count=0
                            )
                        
                        discovered_tools[tool_name].call_count += 1
                        if timestamp:
                            discovered_tools[tool_name].last_seen = timestamp
                
                if "result" in data:
                    result = data.get("result", {})
                    
                    if "tools" in result:
                        for tool_def in result.get("tools", []):
                            tool_name = tool_def.get("name", "unknown")
                            if tool_name not in discovered_tools:
                                discovered_tools[tool_name] = MCPTool(
                                    name=tool_name,
                                    description=tool_def.get("description"),
                                    input_schema=tool_def.get("inputSchema"),
                                    server_name="custom-remote"
                                )
                    
                    if "resources" in result:
                        for res_def in result.get("resources", []):
                            res_name = res_def.get("name", "unknown")
                            if res_name not in discovered_resources:
                                discovered_resources[res_name] = MCPResource(
                                    name=res_name,
                                    uri=res_def.get("uri", ""),
                                    mime_type=res_def.get("mimeType"),
                                    description=res_def.get("description"),
                                    server_name="custom-remote"
                                )
                
                if "error" in data:
                    server_info["total_errors"] += 1
        
        server = MCPServer(
            name="custom-remote",
            server_type=ServerType.CUSTOM_REMOTE,
            transport=TransportType.STREAMABLE_HTTP,
            tools=list(discovered_tools.values()),
            resources=list(discovered_resources.values()),
            first_seen=server_info["first_seen"],
            last_seen=server_info["last_seen"],
            total_requests=server_info["total_requests"],
            total_tool_calls=server_info["total_tool_calls"],
            total_errors=server_info["total_errors"],
            sources=[ArtifactSource.SERVER_LOG],
            client_info={
                "observed_ips": list(server_info["client_ips"]),
                "observed_sessions": list(server_info["session_ids"])
            }
        )
        
        entities.servers.append(server)
        self.logger.info(f"Extracted server with {len(discovered_tools)} tools")
        return entities
    
    def extract_events(self, artifact_path: Union[str, Path]) -> Timeline:
        """Extract events from server logs"""
        path = Path(artifact_path)
        timeline = Timeline()
        timeline.sources = [ArtifactSource.SERVER_LOG]
        
        log_files = self._get_log_files(path)
        pending_requests: Dict[str, Dict] = {}
        
        for log_file in log_files:
            self.logger.info(f"Extracting events from: {log_file}")
            
            for entry in self._read_jsonl(log_file):
                events = self._parse_log_entry(entry, log_file.name, pending_requests)
                for event in events:
                    timeline.add_event(event)
        
        self.logger.info(f"Extracted {len(timeline.events)} events")
        return timeline
    
    def _get_log_files(self, path: Path) -> List[Path]:
        """Get list of log files"""
        if path.is_file():
            return [path]
        
        log_files = []
        log_files.extend(path.glob("*.jsonl"))
        
        if (path / "logs").exists():
            log_files.extend((path / "logs").glob("*.jsonl"))
        
        if (path / "proxy_logs").exists():
            log_files.extend((path / "proxy_logs").glob("*.jsonl"))
        
        log_files.sort(key=lambda f: f.stat().st_mtime)
        return log_files
    
    def _read_jsonl(self, log_file: Path) -> Generator[Dict, None, None]:
        """Read JSONL file"""
        try:
            with open(log_file, 'r', encoding='utf-8') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if not line:
                        continue
                    try:
                        yield json.loads(line)
                    except json.JSONDecodeError as e:
                        self.logger.warning(f"JSON error at {log_file}:{line_num}: {e}")
        except Exception as e:
            self.logger.error(f"Error reading {log_file}: {e}")
    
    def _parse_entry_timestamp(self, entry: Dict) -> Optional[datetime]:
        """Extract timestamp from log entry"""
        if "timestamp" in entry:
            return self._parse_timestamp(entry["timestamp"])
        if "data" in entry and isinstance(entry["data"], dict):
            if "timestamp" in entry["data"]:
                return self._parse_timestamp(entry["data"]["timestamp"])
        return None
    
    def _parse_log_entry(self, entry: Dict, source_file: str,
                        pending_requests: Dict) -> List[MCPEvent]:
        """Parse log entry"""
        events = []
        timestamp = self._parse_entry_timestamp(entry) or datetime.now()

        entry_type = entry.get("type", "")
        data = entry.get("data", entry)
        client_ip = entry.get("client_ip") or data.get("client_ip")
        session_id = entry.get("session_id") or data.get("session_id")

        # File access event
        if entry_type == "file_access" or ("path" in data and "operation" in data):
            event = self._parse_file_access(data, timestamp, source_file, client_ip)
            if event:
                events.append(event)
            return events
        
        # JSON-RPC request
        if "method" in data:
            event = self._parse_jsonrpc_request(
                data, timestamp, source_file, client_ip, session_id, pending_requests
            )
            if event:
                events.append(event)

        # JSON-RPC response
        if "result" in data or "error" in data:
            event = self._parse_jsonrpc_response(data, timestamp, source_file, pending_requests)
            if event:
                events.append(event)
        
        return events
    
    def _parse_file_access(self, data: Dict, timestamp: datetime,
                          source_file: str, client_ip: str = None) -> Optional[FileAccessEvent]:
        """Parse file access log"""
        path = data.get("path", "")
        operation = data.get("operation", "read")
        success = data.get("success", True)
        size_bytes = data.get("size_bytes")
        error = data.get("error")
        
        severity = EventSeverity.INFO
        if not success:
            severity = EventSeverity.WARNING
            if error and ("scope" in error.lower() or "denied" in error.lower() or 
                         "traversal" in error.lower()):
                severity = EventSeverity.SECURITY
        
        return FileAccessEvent(
            timestamp=timestamp,
            event_type=EventType.FILE_ACCESS if success else EventType.FILE_ACCESS_DENIED,
            source=ArtifactSource.SERVER_LOG,
            path=path,
            operation=operation,
            success=success,
            size_bytes=size_bytes,
            error=error,
            client_ip=client_ip,
            severity=severity,
            server_name="custom-remote",
            details={"source_file": source_file}
        )
    
    def _parse_jsonrpc_request(self, data: Dict, timestamp: datetime,
                               source_file: str, client_ip: str,
                               session_id: str, pending_requests: Dict) -> Optional[MCPEvent]:
        """Parse JSON-RPC request"""
        method = data.get("method", "")
        params = data.get("params", {})
        request_id = data.get("id")
        
        if request_id:
            pending_requests[str(request_id)] = {
                "timestamp": timestamp,
                "method": method,
                "params": params
            }
        
        event_type = EventType.UNKNOWN
        tool_name = None
        
        if method == "tools/call":
            event_type = EventType.TOOL_CALL
            tool_name = params.get("name")
            
            return ToolCallEvent(
                timestamp=timestamp,
                event_type=event_type,
                source=ArtifactSource.SERVER_LOG,
                server_name="custom-remote",
                tool_name=tool_name,
                arguments=params.get("arguments", {}),
                request_id=str(request_id) if request_id else None,
                session_id=session_id,
                details={
                    "source_file": source_file,
                    "client_ip": client_ip,
                    "full_params": params
                }
            )
        elif method == "tools/list":
            event_type = EventType.TOOL_LIST
        elif method == "resources/list":
            event_type = EventType.RESOURCE_LIST
        elif method == "resources/read":
            event_type = EventType.RESOURCE_READ
        elif method == "initialize":
            event_type = EventType.CONNECTION_INIT
        
        return MCPEvent(
            timestamp=timestamp,
            event_type=event_type,
            source=ArtifactSource.SERVER_LOG,
            server_name="custom-remote",
            request_id=str(request_id) if request_id else None,
            session_id=session_id,
            details={
                "method": method,
                "params": params,
                "source_file": source_file,
                "client_ip": client_ip
            }
        )
    
    def _parse_jsonrpc_response(self, data: Dict, timestamp: datetime,
                                source_file: str, pending_requests: Dict) -> Optional[MCPEvent]:
        """Parse JSON-RPC response"""
        request_id = data.get("id")
        result = data.get("result")
        error = data.get("error")
        
        original_request = None
        if request_id:
            original_request = pending_requests.pop(str(request_id), None)
        
        is_error = error is not None
        
        if original_request and original_request.get("method") == "tools/call":
            tool_name = original_request.get("params", {}).get("name")
            
            duration_ms = None
            if original_request.get("timestamp"):
                delta = timestamp - original_request["timestamp"]
                duration_ms = delta.total_seconds() * 1000
            
            return ToolResultEvent(
                timestamp=timestamp,
                event_type=EventType.TOOL_RESULT if not is_error else EventType.TOOL_ERROR,
                source=ArtifactSource.SERVER_LOG,
                server_name="custom-remote",
                tool_name=tool_name,
                result=result,
                is_error=is_error,
                error_message=error.get("message") if error else None,
                duration_ms=duration_ms,
                request_id=str(request_id) if request_id else None,
                severity=EventSeverity.ERROR if is_error else EventSeverity.INFO,
                details={
                    "source_file": source_file,
                    "full_result": result if not is_error else None,
                    "full_error": error if is_error else None
                }
            )
        
        event_type = EventType.UNKNOWN
        if original_request:
            method = original_request.get("method", "")
            if method == "initialize":
                event_type = EventType.CONNECTION_READY
        
        if is_error:
            event_type = EventType.TOOL_ERROR
        
        return MCPEvent(
            timestamp=timestamp,
            event_type=event_type,
            source=ArtifactSource.SERVER_LOG,
            server_name="custom-remote",
            request_id=str(request_id) if request_id else None,
            severity=EventSeverity.ERROR if is_error else EventSeverity.INFO,
            details={
                "source_file": source_file,
                "result": result,
                "error": error
            }
        )
    
    def get_security_events(self, artifact_path: Union[str, Path]) -> List[FileAccessEvent]:
        """Extract security-related events only"""
        timeline = self.extract_events(artifact_path)
        return [e for e in timeline.events if e.severity == EventSeverity.SECURITY]
    
    def get_file_access_summary(self, artifact_path: Union[str, Path]) -> Dict[str, Any]:
        """File access summary"""
        timeline = self.extract_events(artifact_path)
        file_accesses = [e for e in timeline.events if isinstance(e, FileAccessEvent)]
        
        return {
            "total_accesses": len(file_accesses),
            "successful": len([e for e in file_accesses if e.success]),
            "failed": len([e for e in file_accesses if not e.success]),
            "security_events": len([e for e in file_accesses if e.severity == EventSeverity.SECURITY]),
            "total_bytes_read": sum(e.size_bytes or 0 for e in file_accesses if e.operation == "read"),
            "unique_paths": list(set(e.path for e in file_accesses)),
            "unique_client_ips": list(set(e.client_ip for e in file_accesses if e.client_ip))
        }
    
    def get_tool_usage_summary(self, artifact_path: Union[str, Path]) -> Dict[str, Any]:
        """Tool usage summary"""
        timeline = self.extract_events(artifact_path)
        
        tool_calls = [e for e in timeline.events if isinstance(e, ToolCallEvent)]
        tool_results = [e for e in timeline.events if isinstance(e, ToolResultEvent)]
        
        tool_stats: Dict[str, Dict] = {}
        
        for call in tool_calls:
            tool_name = call.tool_name or "unknown"
            if tool_name not in tool_stats:
                tool_stats[tool_name] = {"calls": 0, "successes": 0, "errors": 0, "total_duration_ms": 0}
            tool_stats[tool_name]["calls"] += 1
        
        for result in tool_results:
            tool_name = result.tool_name or "unknown"
            if tool_name in tool_stats:
                if result.is_error:
                    tool_stats[tool_name]["errors"] += 1
                else:
                    tool_stats[tool_name]["successes"] += 1
                if result.duration_ms:
                    tool_stats[tool_name]["total_duration_ms"] += result.duration_ms
        
        for stats in tool_stats.values():
            if stats["successes"] > 0:
                stats["avg_duration_ms"] = stats["total_duration_ms"] / stats["successes"]
        
        return {
            "total_tool_calls": len(tool_calls),
            "unique_tools": len(tool_stats),
            "tools": tool_stats
        }